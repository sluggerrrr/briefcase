# Railway Deployment Configuration for Briefcase Backend
# This configuration deploys the FastAPI backend with PostgreSQL database,
# automated lifecycle management via cron jobs, and proper environment setup

services:
  # Main Backend API Service
  web:
    source: apps/backend/app
    build:
      builder: nixpacks
      buildCommand: "pip install -r requirements.txt"
    start: "uvicorn main:app --host 0.0.0.0 --port $PORT"
    env:
      PORT: ${{PORT}}
      DATABASE_URL: ${{DATABASE_URL}}
      SECRET_KEY: ${{SECRET_KEY}}
      ALGORITHM: HS256
      ACCESS_TOKEN_EXPIRE_MINUTES: 30
      REFRESH_TOKEN_EXPIRE_DAYS: 7
      MASTER_KEY: ${{MASTER_KEY}}
      ENCRYPTION_KEY: ${{MASTER_KEY}}
      ENVIRONMENT: production
      CORS_ORIGINS: ${{CORS_ORIGINS}}
      LOG_LEVEL: info
    healthcheck:
      path: /health
      interval: 30
    deploy:
      numReplicas: 1
      restartPolicyType: always
      restartPolicyMaxRetries: 3
    
  # PostgreSQL Database Service
  postgres:
    image: postgres:15-alpine
    env:
      POSTGRES_DB: briefcase_db
      POSTGRES_USER: ${{POSTGRES_USER}}
      POSTGRES_PASSWORD: ${{POSTGRES_PASSWORD}}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $POSTGRES_USER"]
      interval: 10s
      timeout: 5s
      retries: 5
    deploy:
      numReplicas: 1
      restartPolicyType: always
  
  # Cron Job: Document Expiration (runs every 30 minutes)
  expire-documents:
    build:
      context: apps/backend
      dockerfile: Dockerfile
      target: production
    env:
      DATABASE_URL: ${{DATABASE_URL}}
      SECRET_KEY: ${{SECRET_KEY}}
      MASTER_KEY: ${{MASTER_KEY}}
      ENCRYPTION_KEY: ${{MASTER_KEY}}
    cron:
      schedule: "*/30 * * * *"  # Every 30 minutes
    start: .venv/bin/python app/scripts/expire_documents.py
    deploy:
      restartPolicyType: never
  
  # Cron Job: Document Cleanup (runs daily at 2 AM UTC)
  cleanup-documents:
    build:
      context: apps/backend
      dockerfile: Dockerfile
      target: production
    env:
      DATABASE_URL: ${{DATABASE_URL}}
      SECRET_KEY: ${{SECRET_KEY}}
      MASTER_KEY: ${{MASTER_KEY}}
      ENCRYPTION_KEY: ${{MASTER_KEY}}
    cron:
      schedule: "0 2 * * *"  # Daily at 2 AM UTC
    start: .venv/bin/python app/scripts/cleanup_documents.py
    deploy:
      restartPolicyType: never
  
  # Cron Job: Audit Log Cleanup (runs weekly on Sunday at 3 AM UTC)
  cleanup-audit-logs:
    build:
      context: apps/backend
      dockerfile: Dockerfile
      target: production
    env:
      DATABASE_URL: ${{DATABASE_URL}}
      SECRET_KEY: ${{SECRET_KEY}}
      MASTER_KEY: ${{MASTER_KEY}}
      ENCRYPTION_KEY: ${{MASTER_KEY}}
    cron:
      schedule: "0 3 * * 0"  # Weekly on Sunday at 3 AM UTC
    start: .venv/bin/python app/scripts/cleanup_audit_logs.py
    deploy:
      restartPolicyType: never
  
  # Database Migration Service (runs once on deploy)
  migrate:
    build:
      context: apps/backend
      dockerfile: Dockerfile
      target: production
    env:
      DATABASE_URL: ${{DATABASE_URL}}
    start: .venv/bin/alembic upgrade head
    deploy:
      restartPolicyType: never

# Volumes for persistent data
volumes:
  postgres_data:
    mount:
      path: /var/lib/postgresql/data

# Environment Variables (set these in Railway dashboard)
# Required variables:
# - DATABASE_URL: PostgreSQL connection string (automatically provided by Railway)
# - SECRET_KEY: JWT secret key for authentication (generate a strong random string)
# - MASTER_KEY: Master encryption key for documents (generate a strong random string)
# - POSTGRES_USER: PostgreSQL username
# - POSTGRES_PASSWORD: PostgreSQL password
# - CORS_ORIGINS: Comma-separated list of allowed origins (e.g., "https://yourdomain.com,https://www.yourdomain.com")
#
# Optional variables:
# - PORT: Port for the web service (Railway provides this automatically)
# - LOG_LEVEL: Logging level (debug, info, warning, error, critical)
# - ENVIRONMENT: Environment name (development, staging, production)